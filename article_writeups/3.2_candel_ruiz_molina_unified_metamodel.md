# Reflection on [A unified metamodel for NoSQL and relational databases](https://www-sciencedirect-com.proxybz.lib.montana.edu/science/article/pii/S0306437921001149)

#### Candel, C. J., Sevilla Ruiz, D., & García-Molina, J. J. (2022). A unified metamodel for NoSQL and relational databases. Information Systems, 104, 101898. https://doi.org/10.1016/j.is.2021.101898 

[(home)](https://beqpolk1.github.io/csci-592-spring2022/)

---

In “A unified metamodel for NoSQL and relational databases”, the authors present one of the most cohesive strategies for managing heterogeneous data stores that I have seen so far. Not only have Candel et al. devised a metamodel (*U-schema*) capable of representing relational data models, the most popular NoSQL data models (document, key-value, column store, and graph), and structural variations found in NoSQL databases, but they also provide a complete description of forward mappings from each data model to *U-schema* and reverse mappings from *U-schema* to each data model. *U-schema* is specified through the Eclipse modeling framework (EMF), an object-oriented modeling tool that is part of the Ecore project, which has also allowed the authors to quickly develop database tools from model-driven engineering (MDE) techniques.

One aspect I had never fully considered for this type of project/research is the fact that NoSQL databases have no agreed-upon, predefined structure or requirements. Relational systems are beholden to relational algebra and, at this point, even have ISO and ANSI standards and specifications to build to, so they all operate more or less within the same boundaries and requirements; there are no such bounds on NoSQL systems. So, two databases both claiming to be “document stores” could support radically different data access and storage mechanisms. While graph theory is a highly developed mathematical field, there is no set of standard requirements that all graph databases must support. Given this lack of uniform, foundational requirements, the authors here had to explicitly specify what they view as the essential features of each type of considered NoSQL paradigm. This wasn’t totally arbitrary, as they based the supported features on some of the most popular systems for each paradigm, such as MongoDB for document stores and Neo4j for graph databases. Still, I appreciated that they made these considerations very clear and specified what they considered the core features of each type of database.

I also appreciated that their approach foreground concerns around structural variability in NoSQL databases. This relates to the much-discussed “flexibility” of NoSQL systems, where instances of the same entity type may exhibit different structures (i.e. having different properties, relationships, or aggregations). Candel et al. recognize that this is one of the inherent benefits of NoSQL systems and therefore ensure that *U-schema* is capable of capturing and representing these variations.

Since it is specified through EMF, *U-schema* makes use of some basic concepts common to many logical schemas, such as entity types, simple and multivalued attributes, key attributes, and different kinds of relationships between entities, such as aggregation and reference. Aggregation allows objects to be recursively embedded in other objects, yielding hierarchical structures, while references simply “point” to another entity. The authors also incorporate some additional concepts such as relationship types (relevant to graph data models) and structural variations (as noted above). Given a certain entity type *e*, each structural variation of *e* differs from the others by at least one property, and there is a *union schema* of *e* that contains the properties from every structural variation. For NoSQL systems, any entity type can have structural variations. Candel et al. summarize their logical concepts as follows:

> * An entity type has a name and is formed by a set of structural variations.
> * A relationship type (only for graph stores) has a name, is formed by a set of structural variations, and refers to both a source and a target entity type.
> * A structural variation is formed by a set of named properties. The kind of properties depend on the data model, and can be: attributes, keys, aggregates, and references.

---

![*U-schema metamodel*](/images/3.2_u_schema.jpg)

Candel et al.'s unified metamodel, *U-schema*

---

As remarked upon here and in several other papers, most NoSQL systems are “schemaless”, or “schema on read”; in other words, there is no predefined schema that specifies how the data must be organized, but instead the schema is implicit in application logic. Given this, the first step to map any NoSQL database to an instance of *U-schema* is to infer the schema from the database (note that this step is not necessary for relational databases because the schema is already specified). Candel et al. use a MapReduce operation to extract a logical schema from the target NoSQL database, in a manner similar to [another paper that featured Ruiz as an author](2.2_ruiz_morales_molina_versioned_schemas.md) – all of the entities within a database are mapped to a “general” version in a JSON-like format, with specific property values substituted with values representing the property type. These general versions are then reduced to find distinct variations for each entity type. The authors performed some testing and validation around this process, and found that it both accurately captured all structural variations for their test datasets and was also efficient and scalable for different databases.

Once schemas are inferred, Candel et al. then dive into the business of defining the “forward mappings” for each data paradigm to *U-schema*, and “reverse mappings” from *U-schema* to each data paradigm. The forward mappings described are *canonical*, in that the rules correctly map all the characteristics of the data model to *U-schema* concepts. These mappings are defined in a formal way that ensures properties, entities, and relationships are accurately and fully represented in *U-schema* without a loss of information, and that the original database schemas could be extracted from the *U-schema* version. The authors provide detailed explanations for each of the five considered paradigms (graph, document, key-value, column store, and relational), which I will not describe here. One thing I found interesting is that they consider document, key-value, and column stores all under the umbrella of being “aggregate-oriented”, which means that their mappings are mostly the same.

Another interesting point is how they handle *U-schema* elements that may exist in one paradigm but not another, such as *relationship types* that only exist in graph databases, or how relational databases have no concept of *structural variation*. For the former (relationship types), the approach is generally to create new, corresponding entity types in the other data models, with a standard name generated according to rules, and properties that capture the information stored by the relationship type. For the latter (structural variations), they recommend either, again, creating new entity types with standardized names, or creating one relation based on the “union schema” of all the variations (where fields have NULL values depending on whether the field is specified for a certain variation).

Even with the robust, thorough approach, there were a few areas where I thought this paper fell a little short. Firstly, I think there is room for advancement with some of the mapping techniques. For example, when mapping aggregates from *U-schema* to the relational model (a reverse mapping), the authors say there are two options: to either build a new relation linked to with a foreign key, or to embed the fields from the aggregated object into the main entity relation; they don’t necessarily offer advice one way or the other. A similar problem arises for forward mapping relational models into *U-schema*: when should a certain group of fields be represented as an aggregate object? I think that perhaps some automated learning techniques could be used to help with these decisions. There are similar considerations around the forward/reverse mappings for “many-to-many” relationships in the relational model, especially with how those can be detected and automatically mapped to “relationship types” in *U-schema* that could then be used for graph databases.

Also, the authors still seem to be considering the problem from the viewpoint of stitching together many existing, specific NoSQL or SQL systems (such as MongoDB, HBase, and MySQL). I have an intuition that this “confederated” approach may not yield as many benefits as a truly holistic, unified solution. They seem to still be envisioning laying *U-schema* **on top of** a set of existing solutions, and then doing some integration at the application layer. Even with the advent of automated, MDE approaches to cut down on overhead, I suspect that this would still not result in the most natural and, more importantly, efficient solutions. I would love to see the ideas of this paper intertwined with [the last reading on MMDBMS’s](3.1_liu_et_al_multi_model_dbms.md) to build a system that somehow naturally stores data in the *U-schema* model, provides fast access, and can then automatically switch to different data paradigms based on the context.